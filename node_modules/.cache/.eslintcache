[{"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/index.js":"1","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/components/App/App.js":"2","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/_config.js":"3","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/colors.js":"4","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/dummy-data/test-data.js":"5","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/components/Header/Header.js":"6","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/components/TransactionsSelector/TransactionsSelector.js":"7"},{"size":220,"mtime":1696581101753,"results":"8","hashOfConfig":"9"},{"size":16306,"mtime":1697638547753,"results":"10","hashOfConfig":"9"},{"size":668,"mtime":1697615461454,"results":"11","hashOfConfig":"9"},{"size":1090,"mtime":1696581101751,"results":"12","hashOfConfig":"9"},{"size":2573,"mtime":1696581101753,"results":"13","hashOfConfig":"9"},{"size":643,"mtime":1696581101752,"results":"14","hashOfConfig":"9"},{"size":15806,"mtime":1697638568538,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"z0wk3h",{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","suppressedMessages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","suppressedMessages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","suppressedMessages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/index.js",[],[],"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/components/App/App.js",["39","40","41","42"],[],"import {\n  Alert,\n  Container,\n  FormControlLabel,\n  Snackbar,\n  Stack,\n} from \"@mui/material\";\nimport Header from \"../Header/Header\";\nimport {\n  accountDebitors,\n  documents,\n  messagesErreur,\n} from \"../../dummy-data/test-data\";\nimport TransactionsSelector from \"../TransactionsSelector/TransactionsSelector\";\nimport { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport URL_GENERATION from \"../../_config\";\nimport LoadingButton from \"@mui/lab/LoadingButton\";\nimport colors from \"../../colors\";\nimport \"./App.css\";\n\nconst ACCOUNT_DEBITORS = window.comptesDebiteurs ?? accountDebitors;\nconst DOCUMENTS = window.documents ?? documents;\nconst MESSAGES_ERREURS = window.messagesErreurs ?? messagesErreur ?? [];\n\nexport const SURCHARGE = window.surcharge ?? 0;\n\nconst {\n  textColorLight,\n  backgroundColor,\n  actionColor,\n  invalidFields,\n  textColor,\n  errorTextColor,\n  validateFields,\n} = colors;\n\nconst App = () => {\n  const [transactions, setTransactions] = useState([...DOCUMENTS]);\n  const [transactionsToExport, setTransactionsToExport] = useState([]);\n  const [isGrouped, setIsGrouped] = useState(\n    localStorage.getItem(\"isGrouped\") === \"true\" ? true : false\n  );\n  const [loading, setLoading] = useState(false);\n  const [transactionTotals, setTransactionTotals] = useState({});\n  const [debitor, setDebitor] = useState([]);\n\n  const [erreurs, setErreurs] = useState(MESSAGES_ERREURS);\n\n  const [message, setMessage] = useState(null);\n\n  const [hideErrors, setHideErrors] = useState(true);\n\n  const getTransactionsToExportTotal = () => {\n    return transactionsToExport.reduce((acc, { nomCrediteur, ttc }) => {\n      acc[nomCrediteur] = (acc[nomCrediteur] || 0) + Number(ttc);\n      return acc;\n    }, {});\n  };\n\n  const isTransactionInvalid = (nomCrediteur, ttc) => {\n    return (\n      (isGrouped && transactionTotals[nomCrediteur] <= 0) ||\n      (!isGrouped && Number(ttc) <= 0) ||\n      (getTransactionsDatesByCrediteur()?.[nomCrediteur]?.length > 1 &&\n        isGrouped)\n    );\n  };\n\n  const isValidDates = (dateExecution) => {\n    if (\n      new Date(dateExecution.split(\"/\").reverse().join(\"-\"))\n        .toISOString()\n        .split(\"T\")[0] >= new Date().toISOString().split(\"T\")[0]\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  const isTransactionOK = (transactions) => {\n    const totalTransactionsByNomCrediteur = transactions.reduce(\n      (acc, { nomCrediteur, ttc }) => {\n        acc[nomCrediteur] = (acc[nomCrediteur] || 0) + Number(ttc);\n        return acc;\n      },\n      {}\n    );\n    return totalTransactionsByNomCrediteur;\n  };\n\n  const getTransactionsDatesByCrediteur = () => {\n    // Initialisation d'un objet vide pour stocker les résultats\n    const result = {};\n\n    // Parcours de chaque transaction dans le tableau transactionsToExport\n    transactionsToExport.forEach(({ nomCrediteur, date_execution }) => {\n      // Vérification si le créancier existe déjà dans le résultat\n      if (!result.hasOwnProperty(nomCrediteur)) {\n        // Si le créancier n'existe pas, on l'ajoute avec un tableau vide pour les dates\n        result[nomCrediteur] = [];\n      }\n\n      // Vérification si la date_execution existe déjà dans le tableau de dates pour le créancier\n      if (!result[nomCrediteur].includes(date_execution)) {\n        // Si la date_execution n'existe pas, on l'ajoute au tableau de dates pour le créancier\n        result[nomCrediteur].push(date_execution);\n      }\n    });\n\n    // Retourne l'objet contenant le nombre de dates associées à chaque créancier\n    return result;\n  };\n\n  const handleChangeTransactionsToExportDateExecution =\n    (nomCrediteur) => (e) => {\n      const { value } = e.target;\n      let newDate = new Date(value).toLocaleDateString(\"fr-FR\");\n      setTransactionsToExport((transactionsToExport) => {\n        return transactionsToExport.map((transaction) =>\n          transaction.nomCrediteur === nomCrediteur\n            ? { ...transaction, date_execution: newDate }\n            : transaction\n        );\n      });\n      setTransactions((transactions) => {\n        return transactions.map((transaction) =>\n          transaction.nomCrediteur === nomCrediteur\n            ? { ...transaction, date_execution: newDate }\n            : transaction\n        );\n      });\n    };\n\n  const isTransactionToBeExported = (Res_id) => {\n    return transactionsToExport.some(\n      (transaction) => transaction.Res_Id === Res_id\n    );\n  };\n\n  const isAllTransactionsSelected = () => {\n    return transactionsToExport.length === transactions.length;\n  };\n\n  const selectTransaction = (Res_Id) => (e) => {\n    const { checked } = e.target;\n    if (checked) {\n      setTransactionsToExport((transactionsToExport) => [\n        ...transactionsToExport,\n        transactions.find((transaction) => transaction.Res_Id === Res_Id),\n      ]);\n    } else {\n      setTransactionsToExport((transactionsToExport) =>\n        transactionsToExport.filter(\n          (transaction) => transaction.Res_Id !== Res_Id\n        )\n      );\n    }\n  };\n\n  const selectAllTransactions = (e) => {\n    const { checked } = e.target;\n    if (checked) {\n      const validTransactions = transactions.filter(\n        ({ nomCrediteur, ttc, date_execution }) => {\n          return (\n            !isTransactionInvalid(nomCrediteur, ttc) &&\n            isValidDates(date_execution)\n          );\n        }\n      );\n      setTransactionsToExport(validTransactions);\n    } else {\n      setTransactionsToExport([]);\n    }\n  };\n\n  const setGrouped = () => {\n    setIsGrouped(!isGrouped);\n  };\n\n  const handleChangeDebitor = (transactions, nomCrediteur) => (e) => {\n    const { value } = e.target;\n\n    setDebitor((debitor) => {\n      const updatedDebitor = debitor.map((deb) =>\n        deb.nomCrediteur === nomCrediteur ? { ...deb, debitor_id: value } : deb\n      );\n      const existingDebitor = updatedDebitor.find(\n        (deb) => deb.nomCrediteur === nomCrediteur\n      );\n\n      return existingDebitor\n        ? updatedDebitor\n        : [...updatedDebitor, { nomCrediteur, debitor_id: value }];\n    });\n\n    setTransactions((transactions) =>\n      transactions.map((transaction) =>\n        transaction.nomCrediteur === nomCrediteur\n          ? { ...transaction, debitor_id: value }\n          : transaction\n      )\n    );\n    setTransactionsToExport((transactionsToExport) =>\n      transactionsToExport.map((transaction) =>\n        transaction.nomCrediteur === nomCrediteur\n          ? { ...transaction, debitor_id: value }\n          : transaction\n      )\n    );\n\n    const storedDebitors = localStorage.getItem(\"debitors\");\n    const debitorData = storedDebitors ? JSON.parse(storedDebitors) : {};\n    debitorData[nomCrediteur] = value;\n    localStorage.setItem(\"debitors\", JSON.stringify(debitorData));\n  };\n\n  const handleGenerateXML = async (e) => {\n    e.preventDefault();\n\n    // ici on refait un balayage sur les transactions valides avant d'envoyer a l'enregistrement\n    const transactions = transactionsToExport.filter(\n      ({ nomCrediteur, ttc, date_execution }) => {\n        return (\n          isTransactionInvalid(nomCrediteur, ttc) === false &&\n          isValidDates(date_execution)\n        );\n      }\n    );\n    if (transactions.length === 0) {\n      setMessage({\n        status: \"warning\",\n        message: \"Aucune transaction selectionée\",\n      });\n      return;\n    }\n    setLoading(true);\n    const formData = new FormData();\n    formData.append(\"transactions\", JSON.stringify(transactions));\n    formData.append(\"isGrouped\", isGrouped);\n\n    try {\n      const response = await axios({\n        method: \"post\",\n        url: URL_GENERATION,\n        data: formData,\n        responseType: \"blob\",\n      });\n\n      let blob = null;\n\n      if (response.headers[\"content-type\"] === \"application/xml\") {\n        blob = new Blob([response.data], {\n          type: \"application/xml\",\n        });\n      } else if (response.headers[\"content-type\"] === \"application/zip\") {\n        blob = new Blob([response.data], {\n          type: \"application/zip\",\n        });\n      } else {\n        throw new Error(response.data.message);\n      }\n      if (blob) {\n        const url = window.URL.createObjectURL(blob);\n        const link = document.createElement(\"a\");\n        const contentDisposition = response?.headers[\"content-disposition\"];\n        if (contentDisposition?.length > 0) {\n          const filename = contentDisposition?.split(\"filename=\")[1];\n          link.href = url;\n          link.setAttribute(\"download\", filename);\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n        }\n      }\n    } catch (error) {\n      alert(error.message);\n    }\n    setLoading(false);\n  };\n\n  useEffect(() => {\n    let prefs = localStorage.getItem(\"debitors\");\n\n    const favouriteDebitor = ACCOUNT_DEBITORS.find(\n      (debitor) => debitor.favourite === \"1\"\n    );\n\n    if (favouriteDebitor && !prefs) {\n      setMessage({\n        status: \"success\",\n        message: \"Compte favori chargés pour tous les fournisseurs\",\n      });\n      const map1 = new Map();\n      const allCrediteurs = new Set(\n        transactions.map((debitor) => debitor.nomCrediteur)\n      );\n      for (const key of allCrediteurs) {\n        map1.set(key, favouriteDebitor.id);\n      }\n      let infosA = Array.from(map1.entries());\n\n      let newInfosA = infosA.map(([nomCrediteur, debitor_id]) => ({\n        debitor_id,\n        nomCrediteur,\n      }));\n\n      setDebitor(newInfosA);\n\n      setTransactions((transactions) =>\n        transactions.map((transaction) => ({\n          ...transaction,\n          debitor_id: favouriteDebitor.id,\n        }))\n      );\n      setTransactionsToExport((transactionsToExport) =>\n        transactionsToExport.map((transaction) => ({\n          ...transaction,\n          debitor_id: favouriteDebitor.id,\n        }))\n      );\n    }\n\n    if (prefs) {\n      setMessage({\n        status: \"success\",\n        message: \"Comptes personalisés chargés pour les fournisseurs\",\n      });\n      const infosB = Object.entries(JSON.parse(prefs));\n      let newInfos = infosB.map(([nomCrediteur, debitor_id]) => ({\n        debitor_id,\n        nomCrediteur,\n      }));\n\n      setDebitor(newInfos);\n\n      newInfos.map(({ debitor_id, nomCrediteur }) => {\n        setTransactions((transactions) =>\n          transactions.map((transaction) =>\n            transaction.nomCrediteur === nomCrediteur\n              ? { ...transaction, debitor_id }\n              : transaction\n          )\n        );\n        setTransactionsToExport((transactionsToExport) =>\n          transactionsToExport.map((transaction) =>\n            transaction.nomCrediteur === nomCrediteur\n              ? { ...transaction, debitor_id }\n              : transaction\n          )\n        );\n      });\n    }\n  }, []);\n\n  useEffect(() => {\n    setTransactionTotals(isTransactionOK(transactions));\n  }, [transactions]);\n\n  useEffect(() => {\n    // Vérifier si des transactions non valides sont sélectionnées\n    const invalidTransactions = transactionsToExport.filter(\n      ({ nomCrediteur, ttc }) => {\n        return isTransactionInvalid(nomCrediteur, ttc);\n      }\n    );\n\n    if (invalidTransactions.length > 0) {\n      // Filtrer les transactions non valides et mettre à jour transactionsToExport\n      const validTransactions = transactionsToExport.filter(\n        ({ nomCrediteur, ttc }) => {\n          return isTransactionInvalid(nomCrediteur, ttc) === false;\n        }\n      );\n      setTransactionsToExport(validTransactions);\n    }\n  }, [isGrouped, transactions]);\n\n  useEffect(() => {\n    localStorage.setItem(\"isGrouped\", isGrouped);\n  }, [isGrouped]);\n\n  return (\n    <div className=\"App\" style={{ height: \"1vh\" }}>\n      {message && (\n        <Snackbar\n          open={message !== null}\n          autoHideDuration={5000}\n          onClose={() => setMessage(null)}\n          anchorOrigin={{ vertical: \"bottom\", horizontal: \"center\" }}\n        >\n          <Alert\n            severity={message.status}\n            onClose={() => setMessage(null)}\n            sx={{\n              background:\n                message.status === \"error\" ? invalidFields : validateFields,\n              color: message.status === \"error\" ? errorTextColor : textColor,\n            }}\n          >\n            {message.message}\n          </Alert>\n        </Snackbar>\n      )}\n      <Container>\n        {erreurs.length > 0 &&\n          !hideErrors &&\n          erreurs.map((erreur, index) => (\n            <Alert\n              onClose={() =>\n                setErreurs((erreurs) => erreurs.filter((_, i) => i !== index))\n              }\n              key={index}\n              sx={{\n                margin: \"6px\",\n                fontWeight: \"bold\",\n                background: invalidFields,\n                color: errorTextColor,\n              }}\n              severity=\"error\"\n            >\n              {erreur}\n            </Alert>\n          ))}\n        <Header />\n        <Container\n          sx={{\n            display: \"flex\",\n            justifyContent: \"space-between\",\n            width: \"100%\",\n          }}\n        >\n          <FormControlLabel\n            value=\"top\"\n            sx={{\n              color: actionColor,\n              display: \"flex\",\n              padding: \"10px\",\n              margin: \"10px\",\n            }}\n            control={\n              <input\n                type=\"checkbox\"\n                checked={isGrouped}\n                onChange={() => setGrouped()}\n              />\n            }\n            label=\"Regrouper les transactions\"\n            labelPlacement=\"start\"\n          />\n          <FormControlLabel\n            value=\"top\"\n            sx={{\n              color: actionColor,\n              display: \"flex\",\n              padding: \"10px\",\n              margin: \"10px\",\n            }}\n            control={\n              <input\n                type=\"checkbox\"\n                checked={hideErrors}\n                onChange={() => setHideErrors(!hideErrors)}\n              />\n            }\n            label=\"Masquer les erreurs\"\n            labelPlacement=\"start\"\n          />\n          {erreurs.length > 0 && (\n            <Stack>\n              {hideErrors && (\n                <Alert\n                  variant=\"filled\"\n                  severity=\"warning\"\n                  sx={{ background: \"#FFEBD6\", color: \"#FF8040\" }}\n                >\n                  Il y à {erreurs.length} documents en erreur dans l'export\n                </Alert>\n              )}\n            </Stack>\n          )}\n        </Container>\n        <form onSubmit={handleGenerateXML}>\n          <TransactionsSelector\n            transactions={transactions}\n            isTransactionToBeExported={isTransactionToBeExported}\n            handleChangeDebitor={handleChangeDebitor}\n            selectTransaction={selectTransaction}\n            DEBITORS_ACCOUNT={ACCOUNT_DEBITORS}\n            selectAllTransactions={selectAllTransactions}\n            isAllTransactionsSelected={isAllTransactionsSelected}\n            isGrouped={isGrouped}\n            transactionTotals={transactionTotals}\n            isTransactionInvalid={isTransactionInvalid}\n            isValidDates={isValidDates}\n            debitor={debitor}\n            getTransactionsToExportTotal={getTransactionsToExportTotal}\n            getTransactionsDatesByCrediteur={getTransactionsDatesByCrediteur}\n            handleChangeTransactionsToExportDateExecution={\n              handleChangeTransactionsToExportDateExecution\n            }\n          />\n          <Container\n            sx={{\n              display: \"flex\",\n              alignItems: \"center\",\n              flexDirection: \"column\",\n              paddingTop: \"40px\",\n            }}\n          >\n            <LoadingButton\n              disabled={transactionsToExport.length === 0 || loading}\n              sx={{\n                background: actionColor,\n                color: textColorLight,\n                fontWeight: \"bold\",\n                textTransform: \"none\",\n              }}\n              variant=\"contained\"\n              type=\"submit\"\n              loading={loading}\n            >\n              {!loading ? \"Générer l'export SEPA\" : \"XML en cours de création\"}\n            </LoadingButton>\n          </Container>\n        </form>\n      </Container>\n    </div>\n  );\n};\nexport default App;\n","/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/_config.js",[],[],"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/colors.js",[],[],"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/dummy-data/test-data.js",[],[],"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/components/Header/Header.js",[],[],"/Users/pierrefrancoispaoletti/Desktop/export_sepa_transactions_selector/src/components/TransactionsSelector/TransactionsSelector.js",["43","44","45"],[],"import {\n  Alert,\n  Box,\n  Divider,\n  FormControl,\n  Stack,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  Tooltip,\n  Typography,\n} from \"@mui/material\";\nimport { Fragment } from \"react\";\nimport colors from \"../../colors\";\n\nconst {\n  textColor,\n  textColorLight,\n  backgroundColor,\n  invalidFields,\n  errorTextColor,\n  validateFields,\n  borderTable,\n} = colors;\n\nconst TransactionsSelector = ({\n  transactions,\n  isTransactionToBeExported,\n  handleChangeDebitor,\n  selectTransaction,\n  DEBITORS_ACCOUNT,\n  selectAllTransactions,\n  isAllTransactionsSelected,\n  isGrouped,\n  transactionTotals,\n  isTransactionInvalid,\n  isValidDates,\n  debitor,\n  getTransactionsToExportTotal,\n  getTransactionsDatesByCrediteur,\n  handleChangeTransactionsToExportDateExecution,\n}) => {\n  console.log(new Date().toISOString().split(\"T\")[0]);\n  const totalTransactionsToExport = getTransactionsToExportTotal();\n  return (\n    <TableContainer sx={{ maxHeight: \"calc(100vh - 250px)\" }}>\n      <Table stickyHeader>\n        <TableHead\n          sx={{\n            position: \"sticky\",\n            top: 0,\n            boxShadow: \"0px 2px 4px rgba(0, 0, 0, 0.25)\",\n            zIndex: 10000,\n          }}\n        >\n          <TableRow>\n            <TableCell\n              align=\"center\"\n              component=\"th\"\n              scope=\"row\"\n              style={{\n                background: backgroundColor,\n                border: `4px solid ${borderTable}`,\n              }}\n            >\n              <input\n                id=\"check-select-all\"\n                type=\"checkbox\"\n                style={{ color: textColorLight }}\n                checked={isAllTransactionsSelected()}\n                onClick={(e) => selectAllTransactions(e)}\n              />\n            </TableCell>\n            <TableCell\n              component=\"th\"\n              scope=\"row\"\n              align=\"center\"\n              sx={{\n                fontWeight: \"bold\",\n                color: textColorLight,\n                background: backgroundColor,\n              }}\n            >\n              Document\n            </TableCell>\n            <TableCell\n              component=\"th\"\n              scope=\"row\"\n              align=\"center\"\n              sx={{\n                fontWeight: \"bold\",\n                color: textColorLight,\n                background: backgroundColor,\n              }}\n            >\n              Fournisseur\n            </TableCell>\n            <TableCell\n              component=\"th\"\n              scope=\"row\"\n              align=\"center\"\n              sx={{\n                fontWeight: \"bold\",\n                color: textColorLight,\n                background: backgroundColor,\n              }}\n            >\n              IBAN\n            </TableCell>\n            <TableCell\n              component=\"th\"\n              scope=\"row\"\n              align=\"center\"\n              sx={{\n                fontWeight: \"bold\",\n                color: textColorLight,\n                background: backgroundColor,\n              }}\n            >\n              Date d'exécution\n            </TableCell>\n            <TableCell\n              component=\"th\"\n              scope=\"row\"\n              align=\"center\"\n              sx={{\n                fontWeight: \"bold\",\n                color: textColorLight,\n                background: backgroundColor,\n              }}\n            >\n              BIC\n            </TableCell>\n            <TableCell\n              component=\"th\"\n              scope=\"row\"\n              align=\"center\"\n              sx={{\n                fontWeight: \"bold\",\n                color: textColorLight,\n                background: backgroundColor,\n              }}\n            >\n              Montant\n            </TableCell>\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {Object.entries(\n            transactions.reduce(\n              (\n                acc,\n                {\n                  Res_Id,\n                  nomCrediteur,\n                  ibanCrediteur,\n                  bicCrediteur,\n                  ttc,\n                  debitor_id,\n                  date_execution,\n                }\n              ) => {\n                if (!acc[nomCrediteur]) {\n                  acc[nomCrediteur] = [];\n                }\n                acc[nomCrediteur].push({\n                  Res_Id,\n                  nomCrediteur,\n                  ibanCrediteur,\n                  bicCrediteur,\n                  ttc,\n                  debitor_id,\n                  date_execution,\n                });\n                return acc;\n              },\n              {}\n            )\n          ).map(([nomCrediteur, transactions, ttc, Res_Id]) => {\n            return (\n              <Fragment key={nomCrediteur}>\n                <TableRow key={nomCrediteur}>\n                  <TableCell\n                    colSpan={7}\n                    align=\"left\"\n                    sx={{\n                      margin: \"34px 0\",\n                      border: `4px solid ${borderTable}`,\n                    }}\n                  >\n                    <Stack direction=\"row\" spacing={2} alignItems=\"center\">\n                      <Typography\n                        component=\"span\"\n                        sx={{\n                          display: \"inline-block\",\n                          padding: \"10px\",\n                          border: `2px solid ${borderTable}`,\n                        }}\n                      >\n                        <strong>Pour le fournisseur : </strong>\n                        {nomCrediteur}\n                      </Typography>\n                      {/* {((getTransactionsDatesByCrediteur()?.[nomCrediteur]\n                        ?.length > 1 &&\n                        isGrouped) ||\n                        isTransactionInvalid(nomCrediteur)) && (\n                        <Stack justifyContent=\"center\" alignItems=\"center\">\n                          <Alert\n                            severity=\"warning\"\n                            sx={{ marginBottom: \"6px\" }}\n                            variant=\"filled\"\n                          >\n                            Attention : Les dates d'exécution ne sont pas\n                            équivalentes ou la date d'execution est postérieure\n                            à la date du jour. Pour générer un export groupé,\n                            veuillez sélectionner une date d'exécution unique\n                            qui sera appliquée lors de l'export.\n                          </Alert>\n                          <Box>\n                            <FormControl>\n                              <TextField\n                                type=\"date\"\n                                fullWidth={false}\n                                onChange={handleChangeTransactionsToExportDateExecution(\n                                  nomCrediteur\n                                )}\n                                inputProps={{\n                                  min: new Date().toISOString().split(\"T\")[0],\n                                }}\n                              />\n                            </FormControl>\n                          </Box>\n                        </Stack>\n                      )} */}\n                    </Stack>\n                    <FormControl\n                      sx={{ margin: \"34px 0\" }}\n                      fullWidth\n                      required={totalTransactionsToExport[nomCrediteur] > 0}\n                      disabled={\n                        totalTransactionsToExport[nomCrediteur] === undefined ||\n                        (isGrouped &&\n                          getTransactionsDatesByCrediteur()?.[nomCrediteur]\n                            ?.length > 1)\n                      }\n                    >\n                      <label style={{ color: textColor }}>Débiteur</label>\n                      <select\n                        style={{\n                          fontSize: \"1.2rem\",\n                          color: \"#3A96DA\",\n                          fontWeight: \"bold\",\n                        }}\n                        value={\n                          debitor.find((d) => d.nomCrediteur === nomCrediteur)\n                            ?.debitor_id || \"\"\n                        }\n                        onChange={handleChangeDebitor(\n                          transactions,\n                          nomCrediteur\n                        )}\n                      >\n                        {DEBITORS_ACCOUNT.map(\n                          ({ id, nom_debiteur, iban, bic, format }) => (\n                            <option key={id} value={id}>\n                              {`${nom_debiteur} - ${iban} - ${bic} - ${format}`}\n                            </option>\n                          )\n                        )}\n                      </select>\n                    </FormControl>\n                  </TableCell>\n                </TableRow>\n                {transactions.map(\n                  ({\n                    Res_Id,\n                    nomCrediteur,\n                    ibanCrediteur,\n                    bicCrediteur,\n                    ttc,\n                    date_execution,\n                  }) => (\n                    <Tooltip\n                      key={Res_Id}\n                      arrow\n                      title={\n                        isTransactionInvalid(nomCrediteur, ttc) &&\n                        getTransactionsDatesByCrediteur()?.[nomCrediteur]\n                          ?.length === 1\n                          ? `Cette transaction à un montant négatif (${Number(\n                              ttc\n                            ).toFixed(\n                              2\n                            )}) et ne peut pas être inclue dans le fichier d'export`\n                          : (isGrouped &&\n                              getTransactionsDatesByCrediteur()?.[nomCrediteur]\n                                ?.length > 1) ||\n                            !isValidDates(date_execution)\n                          ? `Les transactions selectionées ont une date d'echeance differente ou antérieure à la date du jour`\n                          : `Total transactions : ${\n                              isGrouped\n                                ? Number(\n                                    transactionTotals[nomCrediteur]\n                                  ).toFixed(2)\n                                : Number(ttc).toFixed(2)\n                            } pour ${nomCrediteur}`\n                      }\n                    >\n                      <TableRow\n                        key={Res_Id}\n                        style={\n                          isTransactionInvalid(nomCrediteur, ttc) ||\n                          !isValidDates(date_execution)\n                            ? {\n                                background: invalidFields,\n                                color: errorTextColor,\n                              }\n                            : { background: validateFields }\n                        }\n                      >\n                        <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                          <input\n                            type=\"checkbox\"\n                            style={{ color: backgroundColor }}\n                            checked={\n                              isTransactionToBeExported(Res_Id) &&\n                              isTransactionInvalid(nomCrediteur, ttc) ===\n                                false &&\n                              isValidDates(date_execution)\n                            }\n                            disabled={\n                              isTransactionInvalid(nomCrediteur, ttc) ||\n                              !isValidDates(date_execution)\n                            }\n                            onClick={selectTransaction(Res_Id)}\n                          />\n                        </TableCell>\n                        <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                          {Res_Id}\n                        </TableCell>\n                        <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                          {nomCrediteur}\n                        </TableCell>\n                        <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                          {ibanCrediteur}\n                        </TableCell>\n                        {isValidDates(date_execution) ? (\n                          <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                            {date_execution}\n                          </TableCell>\n                        ) : (\n                          <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                            <FormControl>\n                              <input\n                                type=\"date\"\n                                format=\"dd/MM/yyyy\"\n                                style={{ background: \"white\" }}\n                                min={new Date().toISOString().split(\"T\")[0]}\n                                value={\n                                  new Date(\n                                    date_execution\n                                      .split(\"/\")\n                                      .reverse()\n                                      .join(\"-\")\n                                  )\n                                    .toISOString()\n                                    .split(\"T\")[0]\n                                }\n                                onChange={handleChangeTransactionsToExportDateExecution(\n                                  nomCrediteur\n                                )}\n                              />\n                            </FormControl>\n                          </TableCell>\n                        )}\n                        <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                          {bicCrediteur}\n                        </TableCell>\n                        <TableCell component=\"th\" scope=\"row\" align=\"center\">\n                          {new Intl.NumberFormat(\"fr-FR\", {\n                            minimumFractionDigits: 2,\n                          }).format(Number(ttc.toFixed(2)))}\n                        </TableCell>\n                      </TableRow>\n                    </Tooltip>\n                  )\n                )}\n                {totalTransactionsToExport[nomCrediteur] > 0 && (\n                  <TableRow>\n                    <TableCell sx={{ border: \"none\" }} />\n                    <TableCell sx={{ border: \"none\" }} />\n                    <TableCell sx={{ border: \"none\" }} />\n                    <TableCell sx={{ border: \"none\" }} />\n                    <TableCell sx={{ border: \"none\" }} />\n                    <TableCell sx={{ border: \"none\" }} />\n                    <TableCell\n                      colSpan={1}\n                      align=\"right\"\n                      sx={{\n                        border: `2px solid ${borderTable}`,\n                      }}\n                    >\n                      <Typography sx={{ fontWeight: \"bold\" }}>\n                        TOTAL {nomCrediteur} :{\" \"}\n                        {new Intl.NumberFormat(\"fr-FR\", {\n                          style: \"currency\",\n                          currency: \"EUR\",\n                        }).format(\n                          Number(\n                            totalTransactionsToExport[nomCrediteur].toFixed(2)\n                          )\n                        )}\n                      </Typography>\n                    </TableCell>\n                  </TableRow>\n                )}\n                <div style={{ marginBottom: \"8px\" }} />\n              </Fragment>\n            );\n          })}\n        </TableBody>\n      </Table>\n    </TableContainer>\n  );\n};\n\nexport default TransactionsSelector;\n",{"ruleId":"46","severity":1,"message":"47","line":30,"column":3,"nodeType":"48","messageId":"49","endLine":30,"endColumn":18},{"ruleId":"50","severity":1,"message":"51","line":338,"column":51,"nodeType":"52","messageId":"53","endLine":338,"endColumn":53},{"ruleId":"54","severity":1,"message":"55","line":355,"column":6,"nodeType":"56","endLine":355,"endColumn":8,"suggestions":"57"},{"ruleId":"54","severity":1,"message":"58","line":378,"column":6,"nodeType":"56","endLine":378,"endColumn":31,"suggestions":"59"},{"ruleId":"46","severity":1,"message":"60","line":2,"column":3,"nodeType":"48","messageId":"49","endLine":2,"endColumn":8},{"ruleId":"46","severity":1,"message":"61","line":3,"column":3,"nodeType":"48","messageId":"49","endLine":3,"endColumn":6},{"ruleId":"46","severity":1,"message":"62","line":4,"column":3,"nodeType":"48","messageId":"49","endLine":4,"endColumn":10},"no-unused-vars","'backgroundColor' is assigned a value but never used.","Identifier","unusedVar","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'transactions'. Either include it or remove the dependency array.","ArrayExpression",["63"],"React Hook useEffect has missing dependencies: 'isTransactionInvalid' and 'transactionsToExport'. Either include them or remove the dependency array.",["64"],"'Alert' is defined but never used.","'Box' is defined but never used.","'Divider' is defined but never used.",{"desc":"65","fix":"66"},{"desc":"67","fix":"68"},"Update the dependencies array to be: [transactions]",{"range":"69","text":"70"},"Update the dependencies array to be: [isGrouped, isTransactionInvalid, transactions, transactionsToExport]",{"range":"71","text":"72"},[10769,10771],"[transactions]",[11502,11527],"[isGrouped, isTransactionInvalid, transactions, transactionsToExport]"]